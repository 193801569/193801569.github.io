<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GoBang2.1</title>
    <link rel="stylesheet" type="text/css" href="../bootstrap/bootstrap/css/bootstrap.min.css">
    <style>
        .container {
            position: absolute;
            /*position: relative;*/
            background-color: #2aabd2;
            margin: 0 auto;
            height:100%;
            width:100%;

        }
        .button{
            left:400px;
            top:20px;
            position: absolute;
            /*position: relative;*/
        }
        canvas {
            position: absolute;
            /*position: relative;*/
            background-color: #4cae4c;
            margin: 0 auto;
            padding: 30px ;
            left: 300px;
            top:10px;
            /*text-align: center;*/
        }
    </style>
    <script src="../jQuery/jQuery-3.4.1.min.js"></script>
</head>
<body>
<div class="container"  >
    <canvas id="ctx1" height="590" width="600">
    </canvas>
    <div class="button" >
        <button id="back"type="button" class="btn btn-warning">悔棋</button>
        <button id="replay"  type="button" class="btn btn-danger" width="30">重来</button>
    </div>
</div>
</body>
<script>
    chess={
        a:null,
        b:null,    //记录当前棋子的坐标
        size:13,
        flag:1,//1表示归白子，-1表示黑子归下
        record:[],//记录已经下了的棋子
        init:function(){


        },
        create:function(x,y){

            //这部是出去canvas本身left 和 right的影响，使x and y变成我们想要的相对位置
            //并且一定要一开始就减去left和right，否则达不到像要的效果。
            // this.x=(x-game.left-game.padding);
            x=(x-game.left-game.padding-checkerboard.offsetx);
            y=(y-game.padding-game.top-checkerboard.offsety);
            // this.y=(y-game.padding-game.top);
            this.a=Math.floor(x/checkerboard.cell);
            this.b=Math.floor(y/checkerboard.cell);
            if((x-this.a*checkerboard.cell)>checkerboard.cell/2){this.a++;}
            if((y-this.b*checkerboard.cell)>checkerboard.cell/2){this.b++;}
            //如果此点已经有棋子，就不能画
            if(checkerboard.array[this.a][this.b]!==0) return;
            // this.flag=-this.flag;
            checkerboard.array[this.a][this.b]=this.flag;
            this.record.push([this.a,this.b]);
            this.draw();
            checkerboard.judge();
            this.flag=-this.flag;
        },
        draw:function(){
            this.flag=1;
            for(var i=0;i<this.record.length;i++){
                ctx.beginPath();
                // ctx.arc(a*checkerboard.cell,b*checkerboard.cell,this.size,0,Math.PI*2,true);
                ctx.arc(this.record[i][0]*checkerboard.cell+checkerboard.offsetx,
                    this.record[i][1]*checkerboard.cell+checkerboard.offsety,
                    this.size,0,Math.PI*2,true);
                if(this.flag>0) ctx.fillStyle="#ffffff";
                else ctx.fillStyle="#000000";
                ctx.fill();
                this.flag=-this.flag;
            }
        }
    };
    checkerboard={
        offsetx:30,
        offsety:30,
        lines:19,
        lineWidth :1,
        cell:30,
        width:null,
        height:null,
        array:[], //纪录棋盘上的情况
        count:1,
        dic:{
            1:[-1,0],//向左遍历
            2:[1,0],//向右遍历
            3:[0,-1],//向上遍历
            4:[0,1],//向下遍历
            5:[-1,-1], //向左上遍历
            6:[1,1],//向右下遍历
            7:[1,-1],//向右上遍历
            8:[1,1],//向左下遍历
        },
        init:function(){
            this.width=this.cell*(this.lines-1);
            this.height=this.cell*(this.lines-1);
            temp=[];
            for(var i=0;i<this.lines;i++){
                for(var j=0;j<this.lines;j++){
                    temp.push(0);
                }
                this.array.push(temp);
                temp=[];
            }
        },
        // draw:function(){
        //     ctx.beginPath();
        //     for(var i=0;i<this.lines;i++){
        //         ctx.moveTo(0,i*this.cell);
        //         ctx.lineTo(this.width,i*this.cell);
        //         ctx.moveTo(i*this.cell,0);
        //         ctx.lineTo(i*this.cell,this.height);
        //     }
        //     ctx.stroke();
        // },
        draw:function(){
            ctx.beginPath();
            for(var i=0;i<this.lines;i++){
                ctx.moveTo(this.offsetx,i*this.cell+this.offsety);
                ctx.lineTo(this.width+this.offsetx,i*this.cell+this.offsety);
                ctx.moveTo(i*this.cell+this.offsetx,this.offsety);
                ctx.lineTo(i*this.cell+this.offsetx,this.height+this.offsety);
            }
            ctx.stroke();
        },

        judge:function(){
            // alert(chess.flag)
            count=1;
            // 横方向
            direction=1;
            var xmove,ymove;
            chess.flag=-chess.flag;
            // alert(chess.flag)

            while(1){
                if(direction%2!==0){ count=1;}
                //将如下的语句改成了用dic字典来判断xmove和ymove的值,是对代码的一种优化
                // switch(direction){
                //     case 1:xmove=-1;ymove=0;break; //向左遍历
                //     case 2:xmove=1;ymove=0;break; //向右遍历
                //     case 3:ymove=-1;xmove=0;break; //向上遍历
                //     case 4:ymove=1;xmove=0;break; //向下遍历
                //     case 5:xmove=-1;ymove=-1;break; //向左上遍历
                //     case 6:xmove=1;ymove=1;break; //向右下遍历
                //     case 7:xmove=1;ymove=-1;break; //向右上遍历
                //     case 8:xmove=-1;ymove=1;break; //向左下遍历
                // }

                for(var i=1;i<5;i++){
                    if(count===5){
                        if(chess.flag===1){
                            if(confirm("白方胜利,是否在来一局?")){location.reload();}
                        } else if(chess.flag===-1){
                            if(confirm("黑方胜利,是否在来一局?")){location.reload();}
                        } else alert("flag!=1或者-1,有bug!!!");
                    }
                    // alert((chess.a+this.dic[direction][0]*i)+","+(chess.b+this.dic[direction][1]*i))
                    if(chess.flag===this.array[chess.a+this.dic[direction][0]*i][chess.b+this.dic[direction][1]*i]){
                        count++;
                        // alert(count)
                    } else {
                        break;
                    }

                }
                if(++direction>8){
                    direction=1;
                    return ;
                }
            }
        },
    };
    game={
        left:300,
        top:10,
        padding:30,
        width:600,
        height:590,  //canvas的width和height
        flag:1,//1表示黑棋，0表示白棋
        ctx:null,
        init:function(){
            replay=document.getElementById("replay");
            replay.onclick=function(){
                if(confirm("Are you sure that you want to replay!")){location.reload();}
            };
        },
        run:function(){
            this.init();
            chess.init();
            checkerboard.init();
            // chess.draw();
            checkerboard.draw();
        }
    };

    function init(){
        ctx=document.getElementsByTagName("canvas")[0].getContext("2d");
    };

    $("#ctx1").click(function(event){
        event=event||window.event;
        // alert(event.pageY);
        // alert(game.top+game.padding+checkerboard.offsety)

        if(event.pageY<game.top+game.padding+checkerboard.offsety ||
            event.pageX<game.left+game.padding+checkerboard.offsetx ){return;}

        chess.create(event.pageX,event.pageY);
        // checkerboard.judge();
    });

    $("#back").click(function(){

        ctx.clearRect(0,0,game.width,game.height);
        chess.record.pop();
        checkerboard.draw();
        chess.draw();
    });

    init();
    game.run();
</script>
</html>